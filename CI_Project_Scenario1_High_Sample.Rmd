---
title: "Project"
output: html_document
date: "2024-04-21"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```




## Scenario 1

Simple DAG Structure and Continuous outcome

```{r}
# Set the seed for reproducibility
set.seed(123)

# Define the sample size and missing data percentages
n <- 1000
missing_percentages <- seq(0.05, 0.3, by = 0.05)

# Generate the confounding variables L1, L2, L3
mu <- 0
sigma <- 1
L1 <- rnorm(n, mean = mu, sd = sigma)
L2 <- 0.5 * L1 + rnorm(n, mean = 0, sd = 0.5)
L3 <- 0.7 * L2 + rnorm(n, mean = 0, sd = 0.3)

# Generate the binary treatment A based on L1, L2, L3
A <- rbinom(n, size = 1, prob = plogis(0.4 * L1))

# Generate the continuous outcome Y based on A, L1, L2, L3
Y <- -2 + 1.5 * A + 0.3 * L3 + rnorm(n, mean = 0, sd = 0.5)

# Create a function to introduce missing data in L1
introduce_missing <- function(data, missing_prob) {
  missing_indices <- sample(1:n, size = round(n * missing_prob), replace = FALSE)
  data$L1[missing_indices] <- NA
  return(data)
}

# Create a list to store the datasets with different missing percentages
datasets_cont <- lapply(missing_percentages, function(p) {
  data <- data.frame(L1, L2, L3, A, Y)
  data <- introduce_missing(data, p)
  return(data)
})


```



```{r}
# Generate potential outcomes for each individual
Y_treated <- -2 + 1.5 * 1 + 0.3 * L3 + rnorm(n, mean = 0, sd = 0.5)

Y_untreated <- -2 + 1.5 * 0 + 0.3 * L3 + rnorm(n, mean = 0, sd = 0.5)


# Calculate the true average treatment effect (ATE)
true_ATE <- mean(Y_treated - Y_untreated)

# Print the true ATE
cat("True Average Treatment Effect (ATE):", true_ATE, "\n")
```


```{r}
# Function to estimate the average treatment effect (ATE) using different imputation methods
estimate_ate <- function(data, method) {
  if (method == "mi") {
    # Multiple imputation
    library(mice)
    imputed_data <- mice(data, m = 5, method = "pmm", printFlag = FALSE)
    models <- with(imputed_data, glm(Y ~ A + L1 + L2 + L3, family = gaussian()))
    pooled_coef <- pool(models)
    ate <- pooled_coef[2, 3][3][1,1]
    ci_lower <- ate - 1.96 * sqrt(pooled_coef[2, 3][6])
    ci_lower <- ci_lower[1,1]
    ci_upper <- ate + 1.96 * sqrt(pooled_coef[2, 3][6])
    ci_upper <- ci_upper[1,1]
  } else if (method == "fiml") {
    # Full information maximum likelihood
    library(lavaan)
    model <- '
          Y ~ b1 * A + b2 * L1 + b3 * L2 + b4 * L3
          A ~ a1 * L1 + a2 * L2 + a3 * L3
          L1 ~~ L2
          L1 ~~ L3
          L2 ~~ L3
          L1 ~~ L1
          L2 ~~ L2
          L3 ~~ L3
         '
    fit <- sem(model, data = data, missing = "fiml")
    summary(fit, fit.measures=TRUE, rsquare=TRUE, standardize=TRUE)
    ate <- parameterEstimates(fit)[1,5]
    ci_lower <- ate - 1.96 * parameterEstimates(fit)[1,6]
    ci_upper <- ate + 1.96 * parameterEstimates(fit)[1,6]
  } else if (method == "knn500") {
    # KNN regression imputation with K=500
    library(VIM)
    imputed_data <- kNN(data, variable = "L1", k = 500)
    model <- glm(Y ~ A + L1 + L2 + L3, data = imputed_data, family = gaussian())
    ate <- coef(model)[2]
    ci_lower <- confint(model)[2, ][1]
    ci_upper <- confint(model)[2, ][2]
  } else if (method == "knn100") {
    # KNN regression imputation with K=100
    library(VIM)
    imputed_data <- kNN(data, variable = "L1", k = 100)
    model <- glm(Y ~ A + L1 + L2 + L3, data = imputed_data, family = gaussian())
    ate <- coef(model)[2]
    ci_lower <- confint(model)[2, ][1]
    ci_upper <- confint(model)[2, ][2]
  } else if (method == "rf_flexible") {
    # Random Forest imputation with the most flexible settings
    library(missForest)
    imputed_data <- missForest(data, ntree = 1000, nodesize = c(5,5))$ximp
    model <- glm(Y ~ A + L1 + L2 + L3, data = imputed_data, family = gaussian())
    ate <- coef(model)[2]
    ci_lower <- confint(model)[2, ][1]
    ci_upper <- confint(model)[2, ][2]
  } else if (method == "rf_less_flexible") {
    # Random Forest imputation with the most non-flexible settings
    library(missForest)
    imputed_data <- missForest(data, ntree = 5, nodesize = c(200,5))$ximp
    model <- glm(Y ~ A + L1 + L2 + L3, data = imputed_data, family = gaussian())
    ate <- coef(model)[2]
    ci_lower <- confint(model)[2, ][1]
    ci_upper <- confint(model)[2, ][2]
  }
  
  return(list(ate = ate, ci_lower = ci_lower, ci_upper = ci_upper))
}

# Set the true average treatment effect (ATE)
true_ate <- 1.5

# Specify the imputation methods to explore
# Specify the imputation methods to explore
imputation_methods <- c("mi","fiml","knn500", "knn100", "rf_flexible","rf_less_flexible")

# Initialize a data frame to store the results
results <- data.frame(
  missing_percentage = numeric(),
  imputation_method = character(),
  ate_estimate = numeric(),
  ci_lower = numeric(),
  ci_upper = numeric()
)

# Iterate over the datasets and imputation methods
for (i in seq_along(datasets)) {
  cat("Dataset", i, "with", missing_percentages[i] * 100, "% missing data:\n")
  
  for (method in imputation_methods) {
    cat("  Imputation method:", method, "\n")
    
    # Estimate ATE and confidence interval using the specified imputation method
    ate_estimates <- estimate_ate(datasets_cont[[i]], method)
    
    # Store the results
    results <- rbind(results, data.frame(
      missing_percentage = missing_percentages[i],
      imputation_method = method,
      ate_estimate = ate_estimates$ate,
      ci_lower = ate_estimates$ci_lower,
      ci_upper = ate_estimates$ci_upper
    ))
  }
  
  cat("\n")
}

# Print the results
print(results)
```



## Scenario 2


```{r}
# Set the seed for reproducibility
set.seed(123)

# Define the sample size and missing data percentages
n <- 1000
missing_percentages <- seq(0.05, 0.3, by = 0.05)

# Generate the variables L1, L2, L3, L4, L5, C1

L1 <- rnorm(n, mean = 0, sd = 1)
L2 <- 0.5 * L1 + rnorm(n, mean = 0, sd = 0.5)
L3 <- rnorm(n, mean = 0, sd = 0.3)
L4 <- rnorm(n, mean=0, sd=0.7)
L5 <- rnorm(n, mean=0, sd=0.8)
C1 <- 65*L4 + 55*L5 + rnorm(n, mean=0, sd = 5)

# Generate the binary treatment A based 
A <- rbinom(n, size = 1, prob = plogis(-1 + 0.4 * L4 + 0.3 * L3))

# Generate the continuos mediator M 

M <- 0.9*A + 0.6*L1 + 0.2*L5 + rnorm(n, mean = 0, sd = 0.4)

# Generate the binary outcome Y based on A, L1, L2, L3
Y <- -3 + 1.5*A + 0.6*M + 0.1*L2 + 0.7*L3 + rnorm(n, mean = 0, sd = 1)

# Create a function to introduce missing data in L1
introduce_missing <- function(data, missing_prob) {
  missing_indices <- sample(1:n, size = round(n * missing_prob), replace = FALSE)
  data$L1[missing_indices] <- NA
  return(data)
}

# Create a list to store the datasets with different missing percentages
datasets <- lapply(missing_percentages, function(p) {
  data <- data.frame(L1, L2, L3, L4, L5, C1, A, Y, M)
  data <- introduce_missing(data, p)
  return(data)
})

```


```{r}
# NDE should be close to 1.5 and NIE should be close to 0.54. Let us cross verify 

data_check = data.frame(L1, L2, L3, L4, L5, C1, A, Y, M)

#Estimation
#Fit the mediation model
medFit <- glm(M ~ A , family = gaussian, data = data_check)

#Fit the outcome model
outcomeFit <- glm(Y ~ A + M + L1 + L2 + L3, family = gaussian, data = data_check)

#Fit the mediation model
neMod1 <- mediation::mediate(model.m = medFit, model.y = outcomeFit,
                             treat = "A", mediator = "M", data = data_check, robustSE = TRUE,
                             sims = 2000) 

summary(neMod1)
```


```{r}
# Function to estimate the average treatment effect (ATE) using different imputation methods
estimate_ate <- function(data, method) {
  if (method == "mi") {
    # Multiple imputation
    library(mice)
    imputed_data <- mice(datasets[[1]], m = 5, method = "pmm", printFlag = FALSE)
    imputed_data_1 <- complete(imputed_data,1)
    imputed_data_2 <- complete(imputed_data,2)
    imputed_data_3 <- complete(imputed_data,3)
    imputed_data_4 <- complete(imputed_data,4)
    imputed_data_5 <- complete(imputed_data,5)
    datasets <- list(imputed_data_1=imputed_data_1,imputed_data_2=imputed_data_2,imputed_data_3=imputed_data_3,imputed_data_4=imputed_data_4, imputed_data_5=imputed_data_5)
    mediators <- c("M")
    outcome <- c("Y")
    treatment <- c("A", "A", "A", "A", "A" ) 
    covariates <- c("L1", "L2", "L3")
    olsols <- mediation :: mediations(datasets, treatment, mediators, outcome, covariates, 
                    families=c("gaussian","gaussian","gaussian","gaussian","gaussian"), interaction=FALSE, conf.level=.95, sims=2000)
    output <- mediation :: amelidiate(olsols)
    NDE <- output$z0
    NIE <- output$d0
    ci_NDE_lower <- output$z0.ci[1]
    ci_NDE_upper <- output$z0.ci[2]
    ci_NIE_lower <- output$d0.ci[1]
    ci_NIE_upper <- output$d0.ci[2]
  } else if (method == "fiml") {
    # Full information maximum likelihood
    library(lavaan)
    model <- ' # direct effect
             Y ~ a1*A + a5*L3
           # mediator
             M ~ b1*A
             Y ~ c3*M + c1*L1 + c2*L2
           # indirect effect (a*b)
             NIE := c3*b1
           # total effect
             total := a1 + (c3*b1)
         '
    fit <- sem(model, data = data, missing = "fiml.x")
    NDE <- parameterEstimates(fit)[1,5]
    NIE <- parameterEstimates(fit)[3,5]*parameterEstimates(fit)[4,5]
    ci_NDE_lower <- parameterEstimates(fit)[1,9]
    ci_NDE_upper <- parameterEstimates(fit)[1,10]
    ci_NIE_lower <- parameterEstimates(fit)[3,9]*parameterEstimates(fit)[4,9]
    ci_NIE_upper <- parameterEstimates(fit)[3,10]*parameterEstimates(fit)[4,10]
  } else if (method == "knn500") {
    # KNN regression imputation with K=500
    library(VIM)
    imputed_data <- kNN(data, variable = "L1", k = 500)
    medFit <- glm(M ~ A , family = gaussian, data = imputed_data)
    outcomeFit <- glm(Y ~ A + M + L1 + L2 + L3, family = gaussian, data = imputed_data)
    neMod <- mediation::mediate(model.m = medFit, model.y = outcomeFit,
                             treat = "A", mediator = "M", data = data_check, robustSE = TRUE,
                             sims = 2000) 
    NDE <- neMod$z0
    NIE <- neMod$d0
    ci_NDE_lower <- neMod$z0.ci[1]
    ci_NDE_upper <- neMod$z0.ci[2]
    ci_NIE_lower <- neMod$d0.ci[1]
    ci_NIE_upper <- neMod$d0.ci[2]
  } else if (method == "knn100") {
    # KNN regression imputation with K=100
    library(VIM)
    imputed_data <- kNN(data, variable = "L1", k = 100)
    medFit <- glm(M ~ A , family = gaussian, data = imputed_data)
    outcomeFit <- glm(Y ~ A + M + L1 + L2 + L3, family = gaussian, data = imputed_data)
    neMod <- mediation::mediate(model.m = medFit, model.y = outcomeFit,
                             treat = "A", mediator = "M", data = data_check, robustSE = TRUE,
                             sims = 2000) 
    NDE <- neMod$z0
    NIE <- neMod$d0
    ci_NDE_lower <- neMod$z0.ci[1]
    ci_NDE_upper <- neMod$z0.ci[2]
    ci_NIE_lower <- neMod$d0.ci[1]
    ci_NIE_upper <- neMod$d0.ci[2]
  } else if (method == "rf_flexible") {
    # Random Forest imputation with the most flexible settings
    library(missForest)
    imputed_data <- missForest(data, ntree = 1000, nodesize = c(5,5))$ximp
    medFit <- glm(M ~ A , family = gaussian, data = imputed_data)
    outcomeFit <- glm(Y ~ A + M + L1 + L2 + L3, family = gaussian, data = imputed_data)
    neMod <- mediation::mediate(model.m = medFit, model.y = outcomeFit,
                             treat = "A", mediator = "M", data = data_check, robustSE = TRUE,
                             sims = 2000) 
    NDE <- neMod$z0
    NIE <- neMod$d0
    ci_NDE_lower <- neMod$z0.ci[1]
    ci_NDE_upper <- neMod$z0.ci[2]
    ci_NIE_lower <- neMod$d0.ci[1]
    ci_NIE_upper <- neMod$d0.ci[2]
  } else if (method == "rf_less_flexible") {
    # Random Forest imputation with the most non-flexible settings
    library(missForest)
    imputed_data <- missForest(data, ntree = 5, nodesize = c(200,5))$ximp
    medFit <- glm(M ~ A , family = gaussian, data = imputed_data)
    outcomeFit <- glm(Y ~ A + M + L1 + L2 + L3, family = gaussian, data = imputed_data)
    neMod <- mediation::mediate(model.m = medFit, model.y = outcomeFit,
                             treat = "A", mediator = "M", data = data_check, robustSE = TRUE, 
                             sims = 2000) 
    NDE <- neMod$z0
    NIE <- neMod$d0
    ci_NDE_lower <- neMod$z0.ci[1]
    ci_NDE_upper <- neMod$z0.ci[2]
    ci_NIE_lower <- neMod$d0.ci[1]
    ci_NIE_upper <- neMod$d0.ci[2]
  }
  
  return(list(NDE = NDE, NIE = NIE, ci_NDE_lower = ci_NDE_lower, ci_NDE_upper = ci_NDE_upper, ci_NIE_lower = ci_NIE_lower, ci_NIE_upper = ci_NIE_upper))
}

# Specify the imputation methods to explore
# Specify the imputation methods to explore
imputation_methods <- c("mi","fiml","knn500", "knn100", "rf_flexible","rf_less_flexible")

# Initialize a data frame to store the results
results <- data.frame(
  missing_percentage = numeric(),
  imputation_method = character(),
  NDE_estimate = numeric(),
  NIE_estimate = numeric(),
  ci_NDE_lower = numeric(),
  ci_NDE_upper = numeric(),
  ci_NIE_lower = numeric(),
  ci_NIE_upper = numeric()
)

# Iterate over the datasets and imputation methods
for (i in seq_along(datasets)) {
  cat("Dataset", i, "with", missing_percentages[i] * 100, "% missing data:\n")
  
  for (method in imputation_methods) {
    cat("  Imputation method:", method, "\n")
    
    # Estimate ATE and confidence interval using the specified imputation method
    ate_estimates <- estimate_ate(datasets[[i]], method)
    
    # Store the results
    results <- rbind(results, data.frame(
      missing_percentage = missing_percentages[i],
      imputation_method = method,
      NDE_estimate = ate_estimates$NDE,
      NIE_estimate = ate_estimates$NIE,
      ci_NDE_lower = ate_estimates$ci_NDE_lower,
      ci_NDE_upper = ate_estimates$ci_NDE_upper,
      ci_NIE_lower = ate_estimates$ci_NIE_lower,
      ci_NIE_upper = ate_estimates$ci_NIE_upper
    ))
  }
  
  cat("\n")
}

print(results)
```



## Scenario 1

A) Simple DAG structure with continuous outcome


```{r}
# Load the required packages
library(mice)
library(lavaan)
library(VIM)
library(missForest)
library(dplyr)

# Set the seed for reproducibility
set.seed(123)

# Define the sample size, number of datasets, and missing data percentages
n <- 1000
num_datasets <- 100
missing_percentages <- seq(0.05, 0.3, by = 0.05)

# Function to generate a dataset based on the given data generating process
generate_dataset <- function() {
  # Generate the confounding variables L1, L2, L3
  mu <- 0
  sigma <- 1
  L1 <- rnorm(n, mean = mu, sd = sigma)
  L2 <- 0.5 * L1 + rnorm(n, mean = 0, sd = 0.5)
  L3 <- 0.7 * L2 + rnorm(n, mean = 0, sd = 0.3)

  # Generate the binary treatment A based on L1, L2, L3
  A <- rbinom(n, size = 1, prob = plogis(0.4 * L1))

  # Generate the continuous outcome Y based on A, L1, L2, L3
  Y <- -2 + 1.5 * A + 0.3 * L3 + rnorm(n, mean = 0, sd = 0.5)

  # Generate potential outcomes for each individual
  Y_treated <- -2 + 1.5 * 1 + 0.3 * L3 + rnorm(n, mean = 0, sd = 0.5)
  Y_untreated <- -2 + 1.5 * 0 + 0.3 * L3 + rnorm(n, mean = 0, sd = 0.5)

  # Calculate the true average treatment effect (ATE)
  true_ATE <- mean(Y_treated - Y_untreated)

  return(list(data = data.frame(L1, L2, L3, A, Y), true_ATE = true_ATE))
}

# Function to introduce missing data in L1
introduce_missing <- function(data, missing_prob) {
  missing_indices <- sample(1:n, size = round(n * missing_prob), replace = FALSE)
  data$L1[missing_indices] <- NA
  return(data)
}

# Function to estimate the average treatment effect (ATE) using different imputation methods
estimate_ate <- function(data, method) {
  if (method == "mi") {
    # Multiple imputation
    library(mice)
    imputed_data <- mice(data, m = 5, method = "pmm", printFlag = FALSE)
    models <- with(imputed_data, glm(Y ~ A + L1 + L2 + L3, family = gaussian()))
    pooled_coef <- pool(models)
    ate <- pooled_coef[2, 3][3][1,1]
    ci_lower <- ate - 1.96 * sqrt(pooled_coef[2, 3][6])
    ci_lower <- ci_lower[1,1]
    ci_upper <- ate + 1.96 * sqrt(pooled_coef[2, 3][6])
    ci_upper <- ci_upper[1,1]
  } else if (method == "fiml") {
    # Full information maximum likelihood
    library(lavaan)
    model <- '
          Y ~ b1 * A + b2 * L1 + b3 * L2 + b4 * L3
          A ~ a1 * L1 + a2 * L2 + a3 * L3
          L1 ~~ L2
          L1 ~~ L3
          L2 ~~ L3
          L1 ~~ L1
          L2 ~~ L2
          L3 ~~ L3
         '
    fit <- sem(model, data = data, missing = "fiml")
    summary(fit, fit.measures=TRUE, rsquare=TRUE, standardize=TRUE)
    ate <- parameterEstimates(fit)[1,5]
    ci_lower <- ate - 1.96 * parameterEstimates(fit)[1,6]
    ci_upper <- ate + 1.96 * parameterEstimates(fit)[1,6]
  } else if (method == "knn500") {
    # KNN regression imputation with K=500
    library(VIM)
    imputed_data <- kNN(data, variable = "L1", k = 500)
    model <- glm(Y ~ A + L1 + L2 + L3, data = imputed_data, family = gaussian())
    ate <- coef(model)[2]
    ci_lower <- confint(model)[2, ][1]
    ci_upper <- confint(model)[2, ][2]
  } else if (method == "knn100") {
    # KNN regression imputation with K=100
    library(VIM)
    imputed_data <- kNN(data, variable = "L1", k = 100)
    model <- glm(Y ~ A + L1 + L2 + L3, data = imputed_data, family = gaussian())
    ate <- coef(model)[2]
    ci_lower <- confint(model)[2, ][1]
    ci_upper <- confint(model)[2, ][2]
  } else if (method == "rf_flexible") {
    # Random Forest imputation with the most flexible settings
    library(missForest)
    imputed_data <- missForest(data, ntree = 1000, nodesize = c(5,5))$ximp
    model <- glm(Y ~ A + L1 + L2 + L3, data = imputed_data, family = gaussian())
    ate <- coef(model)[2]
    ci_lower <- confint(model)[2, ][1]
    ci_upper <- confint(model)[2, ][2]
  } else if (method == "rf_less_flexible") {
    # Random Forest imputation with the most non-flexible settings
    library(missForest)
    imputed_data <- missForest(data, ntree = 5, nodesize = c(200,5))$ximp
    model <- glm(Y ~ A + L1 + L2 + L3, data = imputed_data, family = gaussian())
    ate <- coef(model)[2]
    ci_lower <- confint(model)[2, ][1]
    ci_upper <- confint(model)[2, ][2]
  }
  
  return(list(ate = ate, ci_lower = ci_lower, ci_upper = ci_upper))
}


# Specify the imputation methods to explore
imputation_methods <- c("mi", "fiml", "knn500", "knn100", "rf_flexible", "rf_less_flexible")
```


```{r}
# Initialize a data frame to store the coverage probabilities
coverage_probs <- data.frame(
  missing_percentage = numeric(),
  imputation_method = character(),
  coverage_prob = numeric()
)

# Initialize a data frame to store the average relative biases
avg_relative_biases <- data.frame(
  missing_percentage = numeric(),
  imputation_method = character(),
  avg_relative_bias = numeric()
)

# Iterate over the missing percentages
for (missing_prob in missing_percentages) {
  cat("Missing Percentage:", missing_prob * 100, "%\n")

  # Initialize data frames to store the results for the current missing percentage
  current_results <- data.frame(
    dataset = integer(),
    imputation_method = character(),
    ate_estimate = numeric(),
    ci_lower = numeric(),
    ci_upper = numeric(),
    true_ate = numeric()
  )

  # Iterate over the datasets
  for (i in 1:num_datasets) {
    # Generate a dataset
    dataset <- generate_dataset()
    true_ate <- dataset$true_ATE

    # Introduce missing data in L1
    dataset$data <- introduce_missing(dataset$data, missing_prob)

    # Iterate over the imputation methods
    for (method in imputation_methods) {
      # Estimate ATE and confidence interval using the specified imputation method
      ate_estimates <- estimate_ate(dataset$data, method)

      # Store the results for the current dataset and imputation method
      current_results <- rbind(current_results, data.frame(
        dataset = i,
        imputation_method = method,
        ate_estimate = ate_estimates$ate,
        ci_lower = ate_estimates$ci_lower,
        ci_upper = ate_estimates$ci_upper,
        true_ate = true_ate
      ))
    }
  }

  # Calculate the coverage probability for each imputation method
  coverage_prob <- current_results %>%
    group_by(imputation_method) %>%
    summarize(coverage_prob = mean(ci_lower <= true_ate & ci_upper >= true_ate))

  # Calculate the average relative bias for each imputation method
  avg_relative_bias <- current_results %>%
    group_by(imputation_method) %>%
    summarize(avg_relative_bias = mean((ate_estimate - true_ate) / true_ate))

  # Store the coverage probabilities and average relative biases for the current missing percentage
  coverage_probs <- rbind(coverage_probs, data.frame(
    missing_percentage = missing_prob,
    imputation_method = coverage_prob$imputation_method,
    coverage_prob = coverage_prob$coverage_prob
  ))

  avg_relative_biases <- rbind(avg_relative_biases, data.frame(
    missing_percentage = missing_prob,
    imputation_method = avg_relative_bias$imputation_method,
    avg_relative_bias = avg_relative_bias$avg_relative_bias
  ))

  cat("\n")
}

# Print the coverage probabilities
cat("Coverage Probabilities:\n")
print(coverage_probs)

```

```{r}
# Print the average relative biases
cat("\nAverage Relative Biases:\n")
print(avg_relative_biases)
```






