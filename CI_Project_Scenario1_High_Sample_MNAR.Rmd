---
title: "Project"
output: html_document
date: "2024-04-21"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



## Scenario 1

Simple DAG structure with continuous outcome MNAR

```{r}
# Load the required packages
library(mice)
library(lavaan)
library(VIM)
library(missForest)
library(dplyr)

# Set the seed for reproducibility
set.seed(123)

# Define the sample size, number of datasets, and missing data percentages
n <- 1000
num_datasets <- 100
missing_percentages <- seq(0.05, 0.3, by = 0.05)

# Function to generate a dataset based on the given data generating process
generate_dataset <- function() {
  # Generate the confounding variables L1, L2, L3
  mu <- 0
  sigma <- 1
  L1 <- rnorm(n, mean = mu, sd = sigma)
  L2 <- 0.5 * L1 + rnorm(n, mean = 0, sd = 0.5)
  L3 <- 0.7 * L2 + rnorm(n, mean = 0, sd = 0.3)

  # Generate the binary treatment A based on L1, L2, L3
  A <- rbinom(n, size = 1, prob = plogis(0.4 * L1))

  # Generate the continuous outcome Y based on A, L1, L2, L3
  Y <- -2 + 1.5 * A + 0.3 * L3 + rnorm(n, mean = 0, sd = 0.5)

  # Generate potential outcomes for each individual
  Y_treated <- -2 + 1.5 * 1 + 0.3 * L3 + rnorm(n, mean = 0, sd = 0.5)
  Y_untreated <- -2 + 1.5 * 0 + 0.3 * L3 + rnorm(n, mean = 0, sd = 0.5)

  # Calculate the true average treatment effect (ATE)
  true_ATE <- mean(Y_treated - Y_untreated)

  return(list(data = data.frame(L1, L2, L3, A, Y), true_ATE = true_ATE))
}

# Function to introduce missing not at random (MNAR) missingness in L1
introduce_missing_mnar <- function(data, missing_prob) {
  missing_indices <- sample(1:n, size = round(n * missing_prob), replace = FALSE, prob = pnorm(data$L1))
  data$L1[missing_indices] <- NA
  return(data)
}
```

```{r}
# Function to estimate the average treatment effect (ATE) using different imputation methods
estimate_ate <- function(data, method) {
  if (method == "mi") {
    # Multiple imputation
    library(mice)
    imputed_data <- mice(data, m = 5, method = "pmm", printFlag = FALSE)
    models <- with(imputed_data, glm(Y ~ A + L1 + L2 + L3, family = gaussian()))
    pooled_coef <- pool(models)
    ate <- pooled_coef[2, 3][3][1,1]
    ci_lower <- ate - 1.96 * sqrt(pooled_coef[2, 3][6])
    ci_lower <- ci_lower[1,1]
    ci_upper <- ate + 1.96 * sqrt(pooled_coef[2, 3][6])
    ci_upper <- ci_upper[1,1]
  } else if (method == "fiml") {
    # Full information maximum likelihood
    library(lavaan)
    model <- '
      Y ~ b1 * A + b2 * L1 + b3 * L2 + b4 * L3
      A ~ a1 * L1 + a2 * L2 + a3 * L3
      L1 ~~ L2
      L1 ~~ L3
      L2 ~~ L3
      L1 ~~ L1
      L2 ~~ L2
      L3 ~~ L3
     '
    fit <- sem(model, data = data, missing = "fiml")
    summary(fit, fit.measures=TRUE, rsquare=TRUE, standardize=TRUE)
    ate <- parameterEstimates(fit)[1,5]
    ci_lower <- ate - 1.96 * parameterEstimates(fit)[1,6]
    ci_upper <- ate + 1.96 * parameterEstimates(fit)[1,6]
  } else if (method == "knn500") {
    # KNN regression imputation with K=500
    library(VIM)
    imputed_data <- kNN(data, variable = "L1", k = 500)
    model <- glm(Y ~ A + L1 + L2 + L3, data = imputed_data, family = gaussian())
    ate <- coef(model)[2]
    ci_lower <- confint(model)[2, ][1]
    ci_upper <- confint(model)[2, ][2]
  } else if (method == "knn100") {
    # KNN regression imputation with K=100
    library(VIM)
    imputed_data <- kNN(data, variable = "L1", k = 100)
    model <- glm(Y ~ A + L1 + L2 + L3, data = imputed_data, family = gaussian())
    ate <- coef(model)[2]
    ci_lower <- confint(model)[2, ][1]
    ci_upper <- confint(model)[2, ][2]
  } else if (method == "rf_flexible") {
    # Random Forest imputation with the most flexible settings
    library(missForest)
    imputed_data <- missForest(data, ntree = 1000, nodesize = c(5,5))$ximp
    model <- glm(Y ~ A + L1 + L2 + L3, data = imputed_data, family = gaussian())
    ate <- coef(model)[2]
    ci_lower <- confint(model)[2, ][1]
    ci_upper <- confint(model)[2, ][2]
  } else if (method == "rf_less_flexible") {
    # Random Forest imputation with the most non-flexible settings
    library(missForest)
    imputed_data <- missForest(data, ntree = 5, nodesize = c(200,5))$ximp
    model <- glm(Y ~ A + L1 + L2 + L3, data = imputed_data, family = gaussian())
    ate <- coef(model)[2]
    ci_lower <- confint(model)[2, ][1]
    ci_upper <- confint(model)[2, ][2]
  }
  
  return(list(ate = ate, ci_lower = ci_lower, ci_upper = ci_upper))
}

# Specify the imputation methods to explore
imputation_methods <- c("mi", "fiml", "knn500", "knn100", "rf_flexible", "rf_less_flexible")

# Initialize a data frame to store the coverage probabilities
coverage_probs_MNAR <- data.frame(
  missing_percentage = numeric(),
  imputation_method = character(),
  coverage_prob = numeric()
)

# Initialize a data frame to store the average relative biases
avg_relative_biases_MNAR <- data.frame(
  missing_percentage = numeric(),
  imputation_method = character(),
  avg_relative_bias = numeric()
)

# Iterate over the missing percentages
for (missing_prob in missing_percentages) {
  cat("Missing Percentage:", missing_prob * 100, "%\n")

  # Initialize data frames to store the results for the current missing percentage
  current_results <- data.frame(
    dataset = integer(),
    imputation_method = character(),
    ate_estimate = numeric(),
    ci_lower = numeric(),
    ci_upper = numeric(),
    true_ate = numeric()
  )

  # Iterate over the datasets
  for (i in 1:num_datasets) {
    # Generate a dataset
    dataset <- generate_dataset()
    true_ate <- dataset$true_ATE

    # Introduce missing not at random (MNAR) missingness in L1
    dataset$data <- introduce_missing_mnar(dataset$data, missing_prob)

    # Iterate over the imputation methods
    for (method in imputation_methods) {
      # Estimate ATE and confidence interval using the specified imputation method
      ate_estimates <- estimate_ate(dataset$data, method)

      # Store the results for the current dataset and imputation method
      current_results <- rbind(current_results, data.frame(
        dataset = i,
        imputation_method = method,
        ate_estimate = ate_estimates$ate,
        ci_lower = ate_estimates$ci_lower,
        ci_upper = ate_estimates$ci_upper,
        true_ate = true_ate
      ))
    }
  }

  # Calculate the coverage probability for each imputation method
  coverage_prob <- current_results %>%
    group_by(imputation_method) %>%
    summarize(coverage_prob = mean(ci_lower <= true_ate & ci_upper >= true_ate))

  # Calculate the average relative bias for each imputation method
  avg_relative_bias <- current_results %>%
    group_by(imputation_method) %>%
    summarize(avg_relative_bias = mean((ate_estimate - true_ate) / true_ate))

  # Store the coverage probabilities and average relative biases for the current missing percentage
  coverage_probs_MNAR <- rbind(coverage_probs_MNAR, data.frame(
    missing_percentage = missing_prob,
    imputation_method = coverage_prob$imputation_method,
    coverage_prob = coverage_prob$coverage_prob
  ))

  avg_relative_biases_MNAR <- rbind(avg_relative_biases_MNAR, data.frame(
    missing_percentage = missing_prob,
    imputation_method = avg_relative_bias$imputation_method,
    avg_relative_bias = avg_relative_bias$avg_relative_bias
  ))

  cat("\n")
}
```

```{r}
# Print the coverage probabilities
cat("Coverage Probabilities:\n")
print(coverage_probs_MNAR)

# Print the average relative biases
cat("\nAverage Relative Biases:\n")
print(avg_relative_biases_MNAR)
```
